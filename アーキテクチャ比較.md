# レイヤードアーキテクチャとクリーンアーキテクチャの比較解説

## 1. レイヤードアーキテクチャ（Layered Architecture）

### 概要

レイヤードアーキテクチャは、アプリケーションを複数の水平な層（レイヤー）に分割する設計パターンです。各層は特定の責任を持ち、上位層は下位層にのみ依存する構造となっています。

### 基本構造

典型的な 3 層アーキテクチャ：

```
┌─────────────────────────┐
│   プレゼンテーション層    │ ← UI、コントローラー
├─────────────────────────┤
│     ビジネスロジック層    │ ← サービス、ドメイン処理
├─────────────────────────┤
│     データアクセス層     │ ← リポジトリ、データベース
└─────────────────────────┘
```

### 各層の責任

- **プレゼンテーション層**: ユーザーインターフェース、リクエスト処理、レスポンス生成
- **ビジネスロジック層**: アプリケーションの核となるビジネスルール、計算処理
- **データアクセス層**: データの永続化、データベースアクセス、外部サービス連携

### メリット

- **理解しやすさ**: 直感的で学習コストが低い
- **分離**: 各層の責任が明確に分かれている
- **再利用性**: 各層のコンポーネントを他の部分で再利用可能
- **テストしやすさ**: 各層を独立してテストできる

### デメリット

- **結合度の問題**: 上位層が下位層に直接依存するため、変更の影響が伝播しやすい
- **ビジネスロジックの漏出**: データベース制約がビジネスルールに影響を与える可能性
- **柔軟性の欠如**: インフラストラクチャの変更が上位層に影響を与える

## 2. クリーンアーキテクチャ（Clean Architecture）

### 概要

Robert C. Martin（Uncle Bob）が提唱したアーキテクチャパターンで、依存関係逆転の原則を活用してビジネスロジックを外部の詳細から独立させることを目的としています。

### 基本構造

同心円状の層構造：

```
        ┌─────────────────────────────────────────┐
        │           External Interfaces           │ ← UI、DB、Web
        │  ┌───────────────────────────────────┐  │
        │  │         Interface Adapters        │  │ ← Controllers、Gateways
        │  │  ┌─────────────────────────────┐  │  │
        │  │  │      Application Business   │  │  │ ← Use Cases
        │  │  │           Rules             │  │  │
        │  │  │  ┌───────────────────────┐  │  │  │
        │  │  │  │   Enterprise Business │  │  │  │ ← Entities
        │  │  │  │        Rules          │  │  │  │
        │  │  │  └───────────────────────┘  │  │  │
        │  │  └─────────────────────────────┘  │  │
        │  └───────────────────────────────────┘  │
        └─────────────────────────────────────────┘
```

### 各層の責任

- **Entities（エンティティ）**: 最も重要なビジネスルール、企業全体で共有される概念
- **Use Cases（ユースケース）**: アプリケーション固有のビジネスルール、アプリケーションの振る舞い
- **Interface Adapters（インターフェースアダプター）**: データ形式の変換、外部とのやり取りを仲介
- **External Interfaces（外部インターフェース）**: UI、データベース、外部 API 等の具象実装

### 依存関係の方向

**重要な特徴**: 依存関係は常に内側（中心）に向かう

- 外側の層は内側の層を知っているが、内側の層は外側を知らない
- ビジネスロジックは外部の実装詳細に依存しない

### メリット

- **独立性**: ビジネスロジックが外部要因から独立
- **テスタビリティ**: ビジネスロジックを外部依存なしでテスト可能
- **柔軟性**: 外部の変更がビジネスロジックに影響しない
- **保守性**: 変更の影響範囲が限定される

### デメリット

- **複雑性**: 学習コストが高く、実装が複雑
- **オーバーエンジニアリング**: 小規模なアプリケーションには過剰な場合がある
- **開発速度**: 初期開発に時間がかかる

## 3. 両者の違い

| 観点               | レイヤードアーキテクチャ | クリーンアーキテクチャ                 |
| ------------------ | ------------------------ | -------------------------------------- |
| **構造**           | 水平な層構造             | 同心円状の層構造                       |
| **依存方向**       | 上から下への一方向       | 常に内側（中心）向き                   |
| **主な目的**       | 責任の分離               | ビジネスロジックの独立                 |
| **複雑さ**         | シンプル                 | やや複雑                               |
| **学習コスト**     | 低い                     | 高い                                   |
| **変更への対応**   | 下位層の変更が上位に影響 | 外部変更がビジネスロジックに影響しない |
| **テストしやすさ** | 各層を独立してテスト     | ビジネスロジックを完全に独立してテスト |

## 4. 両者の繋がりと関係性

### 進化的関係

クリーンアーキテクチャは、従来のレイヤードアーキテクチャの問題点を解決するために生まれました：

1. **問題の認識**: レイヤードアーキテクチャでは、データベース層の変更がビジネスロジック層に影響を与える問題
2. **解決策の提示**: 依存関係逆転の原則を使ってビジネスロジックを保護
3. **発展形**: クリーンアーキテクチャは、レイヤードアーキテクチャの考え方を基盤としつつ、より厳密な依存関係の制御を実現

### 補完関係

- **レイヤードアーキテクチャ**: 分かりやすさと実装の簡単さが利点
- **クリーンアーキテクチャ**: ビジネスロジックの保護と長期保守性が利点

### 使い分けの指針

#### レイヤードアーキテクチャが適している場面

- 小〜中規模のアプリケーション
- チームの技術レベルがまちまち
- 短期間での開発が必要
- ビジネスルールがシンプル

#### クリーンアーキテクチャが適している場面

- 大規模で複雑なアプリケーション
- 長期間の保守が予想される
- ビジネスルールが複雑
- チームの技術レベルが高い
- 外部依存の変更が頻繁

## 5. 実装における考慮点

### レイヤードアーキテクチャの実装例（Go）

#### models/user.go

```go
package models

import "time"

type User struct {
    ID        int64     `json:"id"`
    Name      string    `json:"name"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
}
```

#### handlers/user_handler.go（プレゼンテーション層）

```go
package handlers

import (
    "encoding/json"
    "net/http"
    "strconv"

    "github.com/gorilla/mux"
    "your-app/models"
    "your-app/services"
)

type UserHandler struct {
    userService *services.UserService
}

func NewUserHandler(userService *services.UserService) *UserHandler {
    return &UserHandler{userService: userService}
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, err := strconv.ParseInt(vars["id"], 10, 64)
    if err != nil {
        http.Error(w, "Invalid user ID", http.StatusBadRequest)
        return
    }

    user, err := h.userService.GetUser(id)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}
```

#### services/user_service.go（ビジネスロジック層）

```go
package services

import (
    "errors"
    "your-app/models"
    "your-app/repositories"
)

type UserService struct {
    userRepo *repositories.UserRepository
}

func NewUserService(userRepo *repositories.UserRepository) *UserService {
    return &UserService{userRepo: userRepo}
}

func (s *UserService) GetUser(id int64) (*models.User, error) {
    if id <= 0 {
        return nil, errors.New("invalid user ID")
    }

    user, err := s.userRepo.FindByID(id)
    if err != nil {
        return nil, err
    }

    if user == nil {
        return nil, errors.New("user not found")
    }

    return user, nil
}

func (s *UserService) CreateUser(name, email string) (*models.User, error) {
    // ビジネスロジック：バリデーション
    if name == "" || email == "" {
        return nil, errors.New("name and email are required")
    }

    // 既存ユーザーチェック
    existing, _ := s.userRepo.FindByEmail(email)
    if existing != nil {
        return nil, errors.New("user with this email already exists")
    }

    user := &models.User{
        Name:  name,
        Email: email,
    }

    return s.userRepo.Create(user)
}
```

#### repositories/user_repository.go（データアクセス層）

```go
package repositories

import (
    "database/sql"
    "time"
    "your-app/models"

    _ "github.com/lib/pq"
)

type UserRepository struct {
    db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository {
    return &UserRepository{db: db}
}

func (r *UserRepository) FindByID(id int64) (*models.User, error) {
    query := `SELECT id, name, email, created_at FROM users WHERE id = $1`

    var user models.User
    err := r.db.QueryRow(query, id).Scan(
        &user.ID, &user.Name, &user.Email, &user.CreatedAt,
    )

    if err != nil {
        if err == sql.ErrNoRows {
            return nil, nil
        }
        return nil, err
    }

    return &user, nil
}

func (r *UserRepository) FindByEmail(email string) (*models.User, error) {
    query := `SELECT id, name, email, created_at FROM users WHERE email = $1`

    var user models.User
    err := r.db.QueryRow(query, email).Scan(
        &user.ID, &user.Name, &user.Email, &user.CreatedAt,
    )

    if err != nil {
        if err == sql.ErrNoRows {
            return nil, nil
        }
        return nil, err
    }

    return &user, nil
}

func (r *UserRepository) Create(user *models.User) (*models.User, error) {
    query := `
        INSERT INTO users (name, email, created_at)
        VALUES ($1, $2, $3)
        RETURNING id`

    user.CreatedAt = time.Now()
    err := r.db.QueryRow(query, user.Name, user.Email, user.CreatedAt).Scan(&user.ID)
    if err != nil {
        return nil, err
    }

    return user, nil
}
```

### クリーンアーキテクチャの実装例（Go）

#### domain/entities/user.go（Entities 層）

```go
package entities

import (
    "errors"
    "time"
    "regexp"
)

type User struct {
    ID        int64
    Name      string
    Email     string
    CreatedAt time.Time
}

// ビジネスルールをエンティティに含める
func NewUser(name, email string) (*User, error) {
    if err := validateName(name); err != nil {
        return nil, err
    }

    if err := validateEmail(email); err != nil {
        return nil, err
    }

    return &User{
        Name:      name,
        Email:     email,
        CreatedAt: time.Now(),
    }, nil
}

func validateName(name string) error {
    if name == "" {
        return errors.New("name cannot be empty")
    }
    if len(name) > 100 {
        return errors.New("name cannot exceed 100 characters")
    }
    return nil
}

func validateEmail(email string) error {
    if email == "" {
        return errors.New("email cannot be empty")
    }

    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    if !emailRegex.MatchString(email) {
        return errors.New("invalid email format")
    }

    return nil
}
```

#### domain/repositories/user_repository.go（Repository Interface）

```go
package repositories

import "your-app/domain/entities"

type UserRepository interface {
    FindByID(id int64) (*entities.User, error)
    FindByEmail(email string) (*entities.User, error)
    Save(user *entities.User) error
    Delete(id int64) error
}
```

#### usecases/user_usecase.go（Use Cases 層）

```go
package usecases

import (
    "errors"
    "your-app/domain/entities"
    "your-app/domain/repositories"
)

type UserUsecase struct {
    userRepo repositories.UserRepository
}

func NewUserUsecase(userRepo repositories.UserRepository) *UserUsecase {
    return &UserUsecase{userRepo: userRepo}
}

type GetUserRequest struct {
    ID int64
}

type CreateUserRequest struct {
    Name  string
    Email string
}

func (u *UserUsecase) GetUser(req GetUserRequest) (*entities.User, error) {
    if req.ID <= 0 {
        return nil, errors.New("invalid user ID")
    }

    user, err := u.userRepo.FindByID(req.ID)
    if err != nil {
        return nil, err
    }

    if user == nil {
        return nil, errors.New("user not found")
    }

    return user, nil
}

func (u *UserUsecase) CreateUser(req CreateUserRequest) (*entities.User, error) {
    // 既存ユーザーチェック
    existingUser, _ := u.userRepo.FindByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("user with this email already exists")
    }

    // エンティティ作成（ビジネスルール適用）
    user, err := entities.NewUser(req.Name, req.Email)
    if err != nil {
        return nil, err
    }

    // 保存
    if err := u.userRepo.Save(user); err != nil {
        return nil, err
    }

    return user, nil
}
```

#### interfaces/controllers/user_controller.go（Interface Adapters 層）

```go
package controllers

import (
    "encoding/json"
    "net/http"
    "strconv"

    "github.com/gorilla/mux"
    "your-app/usecases"
)

type UserController struct {
    userUsecase *usecases.UserUsecase
}

func NewUserController(userUsecase *usecases.UserUsecase) *UserController {
    return &UserController{userUsecase: userUsecase}
}

type UserResponse struct {
    ID    int64  `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

type CreateUserRequest struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

func (c *UserController) GetUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, err := strconv.ParseInt(vars["id"], 10, 64)
    if err != nil {
        http.Error(w, "Invalid user ID", http.StatusBadRequest)
        return
    }

    req := usecases.GetUserRequest{ID: id}
    user, err := c.userUsecase.GetUser(req)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    // エンティティをレスポンス形式に変換
    response := UserResponse{
        ID:    user.ID,
        Name:  user.Name,
        Email: user.Email,
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

func (c *UserController) CreateUser(w http.ResponseWriter, r *http.Request) {
    var reqBody CreateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&reqBody); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }

    req := usecases.CreateUserRequest{
        Name:  reqBody.Name,
        Email: reqBody.Email,
    }

    user, err := c.userUsecase.CreateUser(req)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    response := UserResponse{
        ID:    user.ID,
        Name:  user.Name,
        Email: user.Email,
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(response)
}
```

#### infrastructure/database/user_repository.go（External Interfaces 層）

```go
package database

import (
    "database/sql"
    "your-app/domain/entities"

    _ "github.com/lib/pq"
)

type UserRepositoryImpl struct {
    db *sql.DB
}

func NewUserRepositoryImpl(db *sql.DB) *UserRepositoryImpl {
    return &UserRepositoryImpl{db: db}
}

func (r *UserRepositoryImpl) FindByID(id int64) (*entities.User, error) {
    query := `SELECT id, name, email, created_at FROM users WHERE id = $1`

    var user entities.User
    err := r.db.QueryRow(query, id).Scan(
        &user.ID, &user.Name, &user.Email, &user.CreatedAt,
    )

    if err != nil {
        if err == sql.ErrNoRows {
            return nil, nil
        }
        return nil, err
    }

    return &user, nil
}

func (r *UserRepositoryImpl) FindByEmail(email string) (*entities.User, error) {
    query := `SELECT id, name, email, created_at FROM users WHERE email = $1`

    var user entities.User
    err := r.db.QueryRow(query, email).Scan(
        &user.ID, &user.Name, &user.Email, &user.CreatedAt,
    )

    if err != nil {
        if err == sql.ErrNoRows {
            return nil, nil
        }
        return nil, err
    }

    return &user, nil
}

func (r *UserRepositoryImpl) Save(user *entities.User) error {
    if user.ID == 0 {
        // 新規作成
        query := `
            INSERT INTO users (name, email, created_at)
            VALUES ($1, $2, $3)
            RETURNING id`

        return r.db.QueryRow(query, user.Name, user.Email, user.CreatedAt).Scan(&user.ID)
    } else {
        // 更新
        query := `UPDATE users SET name = $1, email = $2 WHERE id = $3`
        _, err := r.db.Exec(query, user.Name, user.Email, user.ID)
        return err
    }
}

func (r *UserRepositoryImpl) Delete(id int64) error {
    query := `DELETE FROM users WHERE id = $1`
    _, err := r.db.Exec(query, id)
    return err
}
```

#### main.go（依存性注入とアプリケーション起動）

```go
package main

import (
    "database/sql"
    "log"
    "net/http"

    "github.com/gorilla/mux"
    "your-app/infrastructure/database"
    "your-app/interfaces/controllers"
    "your-app/usecases"
)

func main() {
    // データベース接続
    db, err := sql.Open("postgres", "user=username dbname=mydb sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    // 依存性注入（クリーンアーキテクチャの場合）
    userRepo := database.NewUserRepositoryImpl(db)
    userUsecase := usecases.NewUserUsecase(userRepo)
    userController := controllers.NewUserController(userUsecase)

    // ルーティング設定
    r := mux.NewRouter()
    r.HandleFunc("/users/{id}", userController.GetUser).Methods("GET")
    r.HandleFunc("/users", userController.CreateUser).Methods("POST")

    log.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", r))
}
```

## 6. テストの実装例

### レイヤードアーキテクチャのテスト

```go
// services/user_service_test.go
package services

import (
    "testing"
    "your-app/models"
    "your-app/repositories"
)

// モックリポジトリ
type mockUserRepository struct {
    users map[int64]*models.User
}

func (m *mockUserRepository) FindByID(id int64) (*models.User, error) {
    user, exists := m.users[id]
    if !exists {
        return nil, nil
    }
    return user, nil
}

func TestUserService_GetUser(t *testing.T) {
    // テストデータ設定
    mockRepo := &mockUserRepository{
        users: map[int64]*models.User{
            1: {ID: 1, Name: "Test User", Email: "test@example.com"},
        },
    }

    service := NewUserService(mockRepo)

    // テスト実行
    user, err := service.GetUser(1)

    // アサーション
    if err != nil {
        t.Fatalf("Expected no error, got %v", err)
    }
    if user.Name != "Test User" {
        t.Errorf("Expected name 'Test User', got %s", user.Name)
    }
}
```

### クリーンアーキテクチャのテスト

```go
// usecases/user_usecase_test.go
package usecases

import (
    "testing"
    "your-app/domain/entities"
    "your-app/domain/repositories"
)

// モックリポジトリ
type mockUserRepository struct {
    users map[int64]*entities.User
}

func (m *mockUserRepository) FindByID(id int64) (*entities.User, error) {
    user, exists := m.users[id]
    if !exists {
        return nil, nil
    }
    return user, nil
}

func (m *mockUserRepository) Save(user *entities.User) error {
    if user.ID == 0 {
        user.ID = int64(len(m.users) + 1)
    }
    m.users[user.ID] = user
    return nil
}

func TestUserUsecase_CreateUser(t *testing.T) {
    // テストデータ設定
    mockRepo := &mockUserRepository{
        users: make(map[int64]*entities.User),
    }

    usecase := NewUserUsecase(mockRepo)

    // テスト実行
    req := CreateUserRequest{
        Name:  "Test User",
        Email: "test@example.com",
    }

    user, err := usecase.CreateUser(req)

    // アサーション
    if err != nil {
        t.Fatalf("Expected no error, got %v", err)
    }
    if user.Name != "Test User" {
        t.Errorf("Expected name 'Test User', got %s", user.Name)
    }
    if user.ID == 0 {
        t.Error("Expected user ID to be set")
    }
}
```

## まとめ

レイヤードアーキテクチャとクリーンアーキテクチャは、それぞれ異なる場面で価値を発揮します。レイヤードアーキテクチャはシンプルで理解しやすく、多くのプロジェクトで十分な構造を提供します。一方、クリーンアーキテクチャは、より複雑な要件や長期的な保守性が重要なプロジェクトにおいて、ビジネスロジックの独立性と柔軟性を提供します。

どちらを選択するかは、プロジェクトの規模、複雑さ、チームのスキル、長期的な保守計画などを総合的に考慮して決定することが重要です。

### 選択の判断基準

1. **プロジェクトの規模と複雑さ**

   - 小規模: レイヤードアーキテクチャ
   - 大規模・複雑: クリーンアーキテクチャ

2. **開発チームのスキル**

   - 初心者中心: レイヤードアーキテクチャ
   - 経験豊富: クリーンアーキテクチャ

3. **開発期間**

   - 短期: レイヤードアーキテクチャ
   - 長期: クリーンアーキテクチャ

4. **保守性の重要度**
   - 一般的: レイヤードアーキテクチャ
   - 高い: クリーンアーキテクチャ

両方のアーキテクチャパターンを理解し、適切に使い分けることで、プロジェクトの成功確率を高めることができます。
